## GO结构体与接口和反射

### 结构体

> 结构体的概念在软件工程上旧的术语叫 ADT（抽象数据类型：Abstract Data Type），在一些老的编程语言中叫 **记录（Record）**，比如 Cobol，在 C 家族的编程语言中它也存在，并且名字也是 **struct**，在面向对象的编程语言中，跟一个无方法的轻量级类一样。不过因为 Go 语言中没有类的概念，因此在 Go 中结构体有着更为重要的地位。

- 使用 **new** 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：`var t *T = new(T)`

- Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。不像 Java 中的引用类型，一个对象和它里面包含的对象可能会在不同的内存空间中，这点和 Go 语言中的指针很像。下面的例子清晰地说明了这些情况：

```go
type Rect1 struct {Min, Max Point }
type Rect2 struct {Min, Max *Point }
```

- GO结构体可以通过递归模拟各种数据结构包括:链表,二叉树

- Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以如示例 10.3 那样互相转换，同时需要注意其中非法赋值或转换引起的编译错误。

- 结构体工厂  Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂

- **如何强制使用工厂方法**  通过应用可见性规则参考 [4.2.1 节](https://golangcaff.com/docs/the-way-to-go/the-basic-structure-and-elements-of-the-go-program/25)、[9.5 节](https://golangcaff.com/docs/the-way-to-go/92-regexp-package/74)就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。

  ~~~
  type matrix struct {
      ...
  }
  
  func NewMatrix(params) *matrix {
      m := new(matrix) // 初始化 m
      return m
  }
  ~~~

- new()和make()的区别

  - new 返回一个应用



- **结构体可以包含内嵌结构体** 可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go 语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go 语言中，相比较于继承，组合更受青睐。

- 嵌套结构体命名冲突

  1. 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；
  2. 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。

- **方法**  在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。

  > 接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者**不能是一个接口类型**（参考 第 11 章），因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：**invalid receiver type…**。
  >
  > 最后接收者**不能是一个指针类型**，但是它可以是任何其他允许类型的指针。
  >
  > 个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。

- 函数与方法的区别

  > 函数将变量作为参数：**Function1(recv)**
  >
  > 方法在变量上被调用：**recv.Method1()**
  >
  > 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。
  >
  > 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。
  >
  > **方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。**

- 在类型中嵌入功能

  > A：聚合（或组合）：包含一个所需功能类型的具名字段。
  >
  > B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。
  >
  > 

- **继承** GO中的继承

  > 多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。

- 和其他语言比较GO的类型和方法

  > 在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。
  >
  > 在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。

- String（）方法和ge格式化描述符

  1. String 方法类似于PHP中的魔术方法__tostring()   方式用fmt.printf()输出类型格式化描述符为%v时会调用String方法
  2. - %v
     - %T  会给出**类型**的完全规格
     - %#v  会给出**实例**的完整输出

- 垃圾回收和SetFinakizer()

  > Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。可以通过 `runtime` 包访问 GC 进程。

- **类型总结**

  > 在 Go 中，类型就是类（数据和关联的方法）。Go 不知道类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。
  >
  > 在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 **组件编程（Component Programming）**。
  >
  > 许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。



## 接口

> Go 语言不是一种 *“传统”* 的面向对象编程语言：它里面没有类和继承的概念。
>
> 但是 Go 语言里有非常灵活的 **接口** 概念，通过它可以实现很多面向对象的特性。接口提供了一种方式来 **说明** 对象的行为：如果谁能搞定这件事，它就可以用在这儿。
>
> 接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。









> 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。
>
> 编写参数是接口变量的函数，这使得它们更具有一般性。
>
> **使用接口使代码更具有普适性。**
>
> 标准库里到处都使用了这个原则，如果对接口概念没有良好的把握，是不可能理解它是如何构建的。





- 空接口   构建通用类型或包含不同类型变量的数组   