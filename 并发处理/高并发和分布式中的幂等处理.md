# 高并发和分布式中的幂等处理

#### **先来谈下幂等的概念**

**抽象概念**

> 幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。

HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数。

幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。

用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的

**举几个例子：**

1.比如前端对同一表单数据的重复提交，后台应该只会产生一个结果。

2.比如我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱。

3.比如发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃。

4.比如创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单。

还有很多诸如此类的，这些逻辑都需要幂等的特性来支持。

#### **什么情况下需要幂等**

业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如：

用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；

向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。 很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。

#### **幂等VS防重**

**幂等与防重的区别：**

- 重复提交是在**第一次请求已经成功的情况下**，人为的进行多次操作，导致不满足幂等要求的服务多次改变状态。
- 幂等更多使用的情况是**第一次请求不知道结果（比如超时）或者失败的异常情况下**，发起多次请求，目的是多次确认第一次请求成功，却不会因多次请求而出现多次的状态变化。（**重点重点重点！！！**）

是重复提交的情况，和服务幂等的初衷是不同的。

>  重复提交是在第一次请求已经成功的情况下，人为的进行多次操作，导致不满足幂等要求的服务多次改变状态。而幂等更多使用的情况是第一次请求不知道结果（比如超时）或者失败的异常情况下，发起多次请求，目的是多次确认第一次请求成功，却不会因多次请求而出现多次的状态变化。

#### **什么情况下需要保证幂等性**

以SQL为例，有下面三种场景，只有第三种场景需要开发人员使用其他策略保证幂等性：

SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是**天然的幂等**。

UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也**是幂等操作**。

UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种**不是幂等的**。

INSERT tab(f1,f2,f3) value(v1,v2,v3,v4)              在没有指定唯一索引的情况下,每次执行都会发生变化,**不是幂等的**。

#### **为什么要设计幂等性的服务**

幂等可以使得客户端逻辑处理变得简单，但是却以服务逻辑变得复杂为代价。满足幂等服务的需要在逻辑中至少包含两点：

- 首先去查询上一次的执行状态，如果没有则认为是第一次请求
- **在服务改变状态的业务逻辑前，保证防重复提交的逻辑**

#### **幂等的不足**

幂等是为了简化客户端逻辑处理，却增加了服务提供者的逻辑和成本，是否有必要，需要根据具体场景具体分析，因此除了业务上的特殊要求外，尽量不提供幂等的接口。

增加了额外控制幂等的业务逻辑，复杂化了业务功能；

把并行执行的功能改为串行执行，降低了执行效率。

#### **保证幂等策略**

幂等需要通过唯一的业务单号来保证。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。 下面以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。

#### **防重复提交策略**

上述的保证幂等方案是分成两步的，**第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来**。既然得出了这个结论，余下的问题也就变得简单：**把查询和变更状态操作加锁，将并行操作改为串行操作**。



#### **实现幂等性的技术方案**

**查询操作**

> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。

**删除操作**

> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)

**唯一索引，防止新增脏数据**

> 拿资金账户和用户账户来说，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，在新增的时候只有一个请求成功，剩下都会抛出唯一索引重复异常。比如`org.springframework.dao.DuplicateKeyException`，这时候再查询一次就可以了，数据存在，返回结果。

**token机制，防止页面重复提交**

> 要求：页面的数据只能被点击提交一次
>
> 发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
>
> 解决办法：
>
> 集群环境：采用token加redis
>
> 单JVM环境：采用token加redis或token加jvm内存
>
> 处理流程：
>
> 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间
>
> 提交后后台校验token，同时删除token，生成新的token返回
>
> token特点：要申请，一次有效性，可以限流。

注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，

存在并发问题，不建议使用

#### **悲观锁**

获取数据的时候加锁获取 select * from table_xxx where id=’xxx’ for update;  

注意：id字段一定是主键或者唯一索引，不然是锁表，会出事的。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。

#### **乐观锁**

> 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：
>
> 1.通过版本号实现 update table_xxx set name=#name#,version=version+1 where version=#version#  
>
> 2.通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0 
>
> 要求：avai_amount-subAmount >=0 
>
> 这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。  

注意：乐观锁的更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好。 

update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version# 

update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# >= 0

#### **分布式锁**

还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，其实就是为了控制多线程并发的操作，也是分布式系统中经常用到的解决思路。

#### **select + insert**

并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。

**注意****：**核心高并发流程不要用这种方法。

##### **支付缓冲区**

把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。优点是同步转异步，高吞吐。不足是不能及时地返回支付结果，需要后续监听支付结果的异步返回。

#### **状态机幂等**

在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。

注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助。

#### **对外提供接口的api如何保证幂等**

如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)。

**重点：**

对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。

#### **最后总结：**

幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像第三方支付平台，银行，互联网金融公司等涉及的网上资金系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，并会大大降低用户体验。



参考:

[深入理解幂等性](https://www.jianshu.com/p/629f0f3481bf)

[理解幂等性](https://www.jianshu.com/p/9630294bbfd8)

